"use strict";(self.webpackChunkinfra_portal=self.webpackChunkinfra_portal||[]).push([[1603],{3733:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>l,toc:()=>h});var s=t(4848),r=t(8453);t(1470),t(9365);const a={title:"Release Management",sidebar_position:3,toc_min_heading_level:2,toc_max_heading_level:6},i="Release Management Guide",l={id:"knowledge-base/release-management/release-management",title:"Release Management",description:"This document outlines the release management process for Libot Mipuy, which involves multiple teams and services.",source:"@site/docs/knowledge-base/release-management/release-management.mdx",sourceDirName:"knowledge-base/release-management",slug:"/knowledge-base/release-management/",permalink:"/infra-portal/pr-preview/pr-26/docs/knowledge-base/release-management/",draft:!1,unlisted:!1,editUrl:"https://github.com/MapColonies/infra-portal/tree/master/docs/knowledge-base/release-management/release-management.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Release Management",sidebar_position:3,toc_min_heading_level:2,toc_max_heading_level:6},sidebar:"knowledgeBaseSidebar",previous:{title:"tsconfig",permalink:"/infra-portal/pr-preview/pr-26/docs/knowledge-base/packages/tsconfig/"},next:{title:"Pipelines",permalink:"/infra-portal/pr-preview/pr-26/docs/category/pipelines"}},o={},h=[{value:"Libot Version Tag",id:"libot-version-tag",level:2},{value:"Service Branching Strategy",id:"service-branching-strategy",level:2},{value:"Service Release Flow",id:"service-release-flow",level:2},{value:"Helming Strategy",id:"helming-strategy",level:2},{value:"Explanation",id:"explanation",level:3},{value:"Chart Flow",id:"chart-flow",level:3},{value:"Values Flow",id:"values-flow",level:3},{value:"Bundle Strategy",id:"bundle-strategy",level:2}];function c(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"release-management-guide",children:"Release Management Guide"})}),"\n",(0,s.jsxs)(n.p,{children:["This document outlines the release management process for Libot Mipuy, which involves multiple teams and services.\nThe release strategy follows semantic versioning (",(0,s.jsx)(n.a,{href:"https://semver.org/",children:"SemVer"}),') for individual services\nand "Libot version" for managing deployed Libot stack on networks.']}),"\n",(0,s.jsx)(n.h2,{id:"libot-version-tag",children:"Libot Version Tag"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"Libot Version"})," is an alias to a specific ",(0,s.jsx)(n.code,{children:"helm-charts"})," release version. This means that it represents the entirety of all service releases for the production deployment and it's structure."]}),"\n",(0,s.jsx)(n.h2,{id:"service-branching-strategy",children:"Service Branching Strategy"}),"\n",(0,s.jsx)(n.p,{children:"Each service must maintain at least one main branch to track the latest stable release and major version updates:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"master"})}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Represents the latest stable version of the service."}),"\n",(0,s.jsx)(n.li,{children:"Merges to this branch indicate the most recent production-ready release."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"MAJOR.x.x"})})," (e.g., ",(0,s.jsx)(n.code,{children:"1.x.x"}),", ",(0,s.jsx)(n.code,{children:"2.x.x"}),"):","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Tracks the major version series of a service."}),"\n",(0,s.jsx)(n.li,{children:"A new branch is created for every major version that is smaller than the latest major version."}),"\n",(0,s.jsxs)(n.li,{children:["Example:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If a service's latest release version is ",(0,s.jsx)(n.code,{children:"3.3.0"})," and a new bug fix needs to be merged to latest release with major version '2',\na pull request (PR) will be created for both:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"master"})," (represents 3.x.x) - only if the bug fix relevant to this release too"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"2.x.x"})," (to track the new version with the fix)."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Once merged, both branches will represent a release with the bug fix, while the ",(0,s.jsx)(n.code,{children:"1.x.x"})," branch remains unchanged."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"service-release-flow",children:"Service Release Flow"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Releasing Flow",src:t(2688).A+"",width:"792",height:"207"})}),"\n",(0,s.jsx)(n.p,{children:"Explanation:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The developer creates a PR"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"On merging to master:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["release-please takes action and opens a PR release with these changes:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Updating package.json to the new release version"}),"\n",(0,s.jsxs)(n.li,{children:["Updating ",(0,s.jsx)(n.code,{children:"CHANGELOG"})," with the new version"]}),"\n",(0,s.jsxs)(n.li,{children:["Updating ",(0,s.jsx)(n.code,{children:"helm chart"})," version"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["The release version will be based on (",(0,s.jsx)(n.a,{href:"https://semver.org/",children:"SemVer"}),") (according to the PR title)"]})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"On merging the release PR to master:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"release-please will create a new release"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"On new release, some automate workflows will be triggered:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Push to ",(0,s.jsx)(n.code,{children:"NPM"})," (for libraries)"]}),"\n",(0,s.jsxs)(n.li,{children:["Build a docker image and push to registry (if a ",(0,s.jsx)(n.code,{children:"Dockerfile"})," exists)"]}),"\n",(0,s.jsxs)(n.li,{children:["Pack the helm chart and push to registry (if a ",(0,s.jsx)(n.code,{children:"helm"})," chart exists)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"End State:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"New release version based on SemVer"}),"\n",(0,s.jsx)(n.li,{children:"master points to the new release"}),"\n",(0,s.jsx)(n.li,{children:"NPM, Docker and Helm registries updated with the new release"}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsx)(n.p,{children:"The deployment part is described in the next section"})}),"\n",(0,s.jsx)(n.h2,{id:"helming-strategy",children:"Helming Strategy"}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"This strategy does not include the checks during development.\nIt assumes that the new released service is properly checked and its updated chart is good.\nAll the development tests should happen before the service was released so in this flow we assume\nthat the chart is good and does not require deployment in order to know if it is a good chart"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Helming Strategy",src:t(4666).A+"",width:"729",height:"335"})}),"\n",(0,s.jsx)(n.p,{children:"The project includes two different repositories that represent two different flows:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:'Chart Flow using "Helm-Charts" repo'}),' - Handling the new charts and versions from the services and creation of new "Libot Version"']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:'Values Flow using "Helm-Values" repo'}),' - Handling the deployment in openshift based on the new "Libot Version" that was created in ',(0,s.jsx)(n.code,{children:"helm-charts"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"explanation",children:"Explanation"}),"\n",(0,s.jsx)(n.p,{children:"With this strategy, we separate the charts from the values."}),"\n",(0,s.jsxs)(n.p,{children:['"helm-charts" repo will contain only the chart. The structure of the helm.',(0,s.jsx)(n.br,{}),"\n",'"helm-values" repo will contain ',(0,s.jsx)(n.strong,{children:"only the values based on the relevant chart"}),'\nand the "Libot Version" it based on (a file named "libot-version.json" in the repo).\nThe values files that represent namespaces of openshift should not be part of the structure\n(as they only config files). They should be in a different repo.',(0,s.jsx)(n.br,{}),"\n","That's way we earn:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:'Avoiding "trash" commits'}),(0,s.jsx)(n.br,{}),"\n","Imagine if we keep the values with the chart, Now if we want to change the log level from info to debug,\nwe will have to commit the change in the repo itself and this shouldn't be.\nThat way we will \"trash\" the repo with a lot with unnecessary commits that don't related to chart itself."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Allowing informative versions of helm-charts"}),(0,s.jsx)(n.br,{}),"\n",'If we keep the chart and the values together, We will have a hard time to handle properly the release of helm-chart\nduo to the many changes on the values that does not require a new release.\nFrom the other hand, there are changes in the values file that we want to change. Imagine that you want to change the default port to be 80.\nThis is a "structure" change because you want to change a default value so it does require a new release.\nSo you won\'t know what requires a new release and what is not.\nWith the separated values and charts, you will have just default values in the chart so every change in that values file will require new release.']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"One and only structure"}),"\nCurrently, the charts in the network can be different from the charts in Azure because the charts can be modified.\nUsing the new strategy, we make sure that there will be one source of truth and it sits in helm-charts outside the internal network and only there!"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Simpler deployment"}),(0,s.jsx)(n.br,{}),"\n",'IF we keep them together, we will need to manage every chart (along with the values) in different branches.\nThat way we will have hard time to manage the charts in all the branches.\nWith the new strategy, we need to "worry" only the values and the version of the chart when we deploy. We won\'t manage the chart anymore.',(0,s.jsx)(n.br,{}),"\n","We can only run this command template:",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.code,{children:"helm install myrelease oci://HELM_REGISTRY/helm-charts/raster-ingestion --version 3.1.0"}),(0,s.jsx)(n.br,{}),"\n","And that's it! We don't need the chart in the repo anymore. We make the structure and the config independent to each other."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Let's walk through the flows!"}),"\n",(0,s.jsx)(n.h3,{id:"chart-flow",children:"Chart Flow"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Chart Flow",src:t(3399).A+"",width:"729",height:"174"})}),"\n",(0,s.jsx)(n.p,{children:'This flow suppose to handle the update of new versions of services and creation of new "Libot Release".'}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"When a service has a new release and helm folder (points that its chart in helm-charts needs to be updated),\nopen a PR in helm-charts that update the version of the service."}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"The developer should see the PR and make more changes if necessary"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"After the PR is ready, merge the PR."}),"\n"]}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsx)(n.p,{children:"The PR can contain multiple commits so if there are more than one service that triggered the PR (more than one chart that needs to be updated),\nthe PR will contain all the changes so the merge of the PR will update the versions of all the relevant services in helm-charts."}),(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"If there is a service that you don't want to include it yet in helm-charts, you can disable the workflow that triggers that PR"})})]}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:['On "master" push:',"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:'Create a new "Libot Version" using release-please.\nThe release-please should also update the docker and helm versions of the services in:'}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"artifacts.json"})," file inside the domain that represent the information of all services and versions of the domain"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"libot-artifacts.json"})," in the root directory that represent the information of all services and versions of ",(0,s.jsx)(n.strong,{children:"all"})," domains"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Package all the charts and push them to helm registry.",(0,s.jsx)(n.br,{}),"\n","For example:",(0,s.jsx)(n.br,{}),"\n","On new libot release with version 3.0.1, we will push to helm registry the raster-ingestion chart with this name: ",(0,s.jsx)(n.code,{children:"rater-ingestion-3.0.1"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"End State"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'New "Libot Version"'}),"\n",(0,s.jsx)(n.li,{children:"Charts of the new version packed in helm registry."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Now, we have an updated structure of the chart and we can move on to the values."}),"\n",(0,s.jsx)(n.h3,{id:"values-flow",children:"Values Flow"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Values Flow",src:t(7091).A+"",width:"729",height:"172"})}),"\n",(0,s.jsx)(n.p,{children:"This flow suppose to handle the update of the namespaces values (integration and prod) and the deployment in openshift."}),"\n",(0,s.jsxs)(n.ol,{start:"0",children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["On new release, there will be a PR on stage branch in ",(0,s.jsx)(n.code,{children:"helm-values"}),' repo that updates the "Libot Version" in ',(0,s.jsx)(n.code,{children:"libot-version.json"})," file"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:'There will be an auto deploy in "integration" namespace'}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"After testing it and make sure the values are OK, the developer will merge the PR"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:'Once the stage branch is updated, a new PR will be automatically created in "prod" branch to update the "Libot Version" in the file'}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The developer will manually deploy using the prod values file"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:'After testing it and make sure the values are OK, the developer will merge the PR to "prod" branch'}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"End State"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'Updated values in all branches based on "Libot Version"'}),"\n",(0,s.jsxs)(n.li,{children:["Updated ",(0,s.jsx)(n.code,{children:"libot-version.json"})," file in every branch"]}),"\n",(0,s.jsx)(n.li,{children:"Updated deployments in all namespaces in openshift"}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["The values flow is the same flow in the network.\nThere will be helm-values repo based on branches (each branch will represent a namespace in openshift)\nand in every branch there will be a file named: ",(0,s.jsx)(n.code,{children:"libot-version.json"})," that will represent the related chart version"]})}),"\n",(0,s.jsx)(n.h2,{id:"bundle-strategy",children:"Bundle Strategy"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Bundling Strategy",src:t(6102).A+"",width:"567",height:"225"})}),"\n",(0,s.jsxs)(n.p,{children:["You can see more about bundler and unbundler ",(0,s.jsx)(n.a,{href:"/infra-portal/pr-preview/pr-26/docs/knowledge-base/DevOps/pipelines/bundler-unbundler",children:"here"}),".",(0,s.jsx)(n.br,{}),"\n",'The only change is that the bundler pipeline will be able to create a bundle based on the "Libot Version".']})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},9365:(e,n,t)=>{t.d(n,{A:()=>i});t(6540);var s=t(4164);const r={tabItem:"tabItem_Ymn6"};var a=t(4848);function i(e){let{children:n,hidden:t,className:i}=e;return(0,a.jsx)("div",{role:"tabpanel",className:(0,s.A)(r.tabItem,i),hidden:t,children:n})}},1470:(e,n,t)=>{t.d(n,{A:()=>y});var s=t(6540),r=t(4164),a=t(3104),i=t(6347),l=t(205),o=t(7485),h=t(1682),c=t(679);function d(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:n,children:t}=e;return(0,s.useMemo)((()=>{const e=n??function(e){return d(e).map((e=>{let{props:{value:n,label:t,attributes:s,default:r}}=e;return{value:n,label:t,attributes:s,default:r}}))}(t);return function(e){const n=(0,h.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function p(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:t}=e;const r=(0,i.W6)(),a=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,o.aZ)(a),(0,s.useCallback)((e=>{if(!a)return;const n=new URLSearchParams(r.location.search);n.set(a,e),r.replace({...r.location,search:n.toString()})}),[a,r])]}function x(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,a=u(e),[i,o]=(0,s.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const s=t.find((e=>e.default))??t[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:n,tabValues:a}))),[h,d]=m({queryString:t,groupId:r}),[x,g]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[r,a]=(0,c.Dv)(t);return[r,(0,s.useCallback)((e=>{t&&a.set(e)}),[t,a])]}({groupId:r}),f=(()=>{const e=h??x;return p({value:e,tabValues:a})?e:null})();(0,l.A)((()=>{f&&o(f)}),[f]);return{selectedValue:i,selectValue:(0,s.useCallback)((e=>{if(!p({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);o(e),d(e),g(e)}),[d,g,a]),tabValues:a}}var g=t(2303);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var j=t(4848);function b(e){let{className:n,block:t,selectedValue:s,selectValue:i,tabValues:l}=e;const o=[],{blockElementScrollPositionUntilNextRender:h}=(0,a.a_)(),c=e=>{const n=e.currentTarget,t=o.indexOf(n),r=l[t].value;r!==s&&(h(n),i(r))},d=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=o.indexOf(e.currentTarget)+1;n=o[t]??o[0];break}case"ArrowLeft":{const t=o.indexOf(e.currentTarget)-1;n=o[t]??o[o.length-1];break}}n?.focus()};return(0,j.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":t},n),children:l.map((e=>{let{value:n,label:t,attributes:a}=e;return(0,j.jsx)("li",{role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,ref:e=>o.push(e),onKeyDown:d,onClick:c,...a,className:(0,r.A)("tabs__item",f.tabItem,a?.className,{"tabs__item--active":s===n}),children:t??n},n)}))})}function v(e){let{lazy:n,children:t,selectedValue:a}=e;const i=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===a));return e?(0,s.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,j.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==a})))})}function w(e){const n=x(e);return(0,j.jsxs)("div",{className:(0,r.A)("tabs-container",f.tabList),children:[(0,j.jsx)(b,{...n,...e}),(0,j.jsx)(v,{...n,...e})]})}function y(e){const n=(0,g.A)();return(0,j.jsx)(w,{...e,children:d(e.children)},String(n))}},6102:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/bundler-strategy-087b699ba87f91b0c41b8966cff82f54.png"},3399:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/chart-flow-78421f874a48dc7f6026532cdb5bebff.png"},4666:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/helm-strategy-c3f931eec12a8f2e1c1dcd30785e40d7.png"},2688:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/release-on-repo-85c09b71b450cb7a6754bf597310c814.png"},7091:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/values-flow-d4c64f0fbbc851d4f7581ac37d9f2e5e.png"},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var s=t(6540);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);