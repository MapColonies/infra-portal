"use strict";(self.webpackChunkinfra_portal=self.webpackChunkinfra_portal||[]).push([[1603],{8164:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"knowledge-base/release-management/release-management","title":"Release Management","description":"This document outlines the release management process for Libot Mipuy, which involves multiple teams and services.","source":"@site/docs/knowledge-base/release-management/release-management.mdx","sourceDirName":"knowledge-base/release-management","slug":"/knowledge-base/release-management/","permalink":"/infra-portal/pr-preview/pr-26/docs/knowledge-base/release-management/","draft":false,"unlisted":false,"editUrl":"https://github.com/MapColonies/infra-portal/tree/master/docs/knowledge-base/release-management/release-management.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Release Management","sidebar_position":3,"toc_min_heading_level":2,"toc_max_heading_level":6},"sidebar":"knowledgeBaseSidebar","previous":{"title":"tsconfig","permalink":"/infra-portal/pr-preview/pr-26/docs/knowledge-base/packages/tsconfig/"},"next":{"title":"Pipelines","permalink":"/infra-portal/pr-preview/pr-26/docs/category/pipelines"}}');var r=t(4848),a=t(8453);t(1470),t(9365);const i={title:"Release Management",sidebar_position:3,toc_min_heading_level:2,toc_max_heading_level:6},l="Release Management Guide",o={},h=[{value:"Libot Version",id:"libot-version",level:2},{value:"Service Branching Strategy",id:"service-branching-strategy",level:2},{value:"Service Release Flow",id:"service-release-flow",level:2},{value:"Helming Strategy",id:"helming-strategy",level:2},{value:"Explanation",id:"explanation",level:3},{value:"Chart Flow",id:"chart-flow",level:3},{value:"Values Flow",id:"values-flow",level:3},{value:"Next Step - Create &quot;Libot Version&quot;",id:"next-step---create-libot-version",level:2},{value:"Libot Version Strategy",id:"libot-version-strategy",level:3},{value:"Bundle Strategy",id:"bundle-strategy",level:3}];function c(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"release-management-guide",children:"Release Management Guide"})}),"\n",(0,r.jsxs)(n.p,{children:["This document outlines the release management process for Libot Mipuy, which involves multiple teams and services.\nThe release strategy follows semantic versioning (",(0,r.jsx)(n.a,{href:"https://semver.org/",children:"SemVer"}),') for individual services\nand the "Libot version" which is used for managing our deployment stack in different networks.']}),"\n",(0,r.jsx)(n.h2,{id:"libot-version",children:"Libot Version"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"Libot Version"})," is an alias to specific versions of various domains within the ",(0,r.jsx)(n.code,{children:"helm-charts"}),' repository\n(which serves as our "one source of truth" for the structure of helm, as explained below in ',(0,r.jsx)(n.a,{href:"#helming-strategy",children:"Helming Strategy"}),")."]}),"\n",(0,r.jsx)(n.p,{children:"This means that it encompasses the entirety of all service releases for the production deployment and its structure."}),"\n",(0,r.jsx)(n.h2,{id:"service-branching-strategy",children:"Service Branching Strategy"}),"\n",(0,r.jsx)(n.p,{children:"Each service must maintain at least one main branch to track the latest stable release and major version updates:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"master"})}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Represents the latest stable version of the service."}),"\n",(0,r.jsx)(n.li,{children:"Merges to this branch indicate the most recent production-ready release."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"MAJOR.x.x"})})," (e.g., ",(0,r.jsx)(n.code,{children:"1.x.x"}),", ",(0,r.jsx)(n.code,{children:"2.x.x"}),"):","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Tracks the major version series of a service."}),"\n",(0,r.jsx)(n.li,{children:"A new branch is created for every major version that is smaller than the latest major version."}),"\n",(0,r.jsxs)(n.li,{children:["Example:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If a service's latest release version is ",(0,r.jsx)(n.code,{children:"3.3.0"})," and a new bug fix needs to be merged to latest release with major version '2',\na pull request (PR) will be created for both:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"master"})," (represents 3.x.x) - only if the bug fix relevant to this release too"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"2.x.x"})," (to track the new version with the fix)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Once merged, both branches will represent a release with the bug fix, while the ",(0,r.jsx)(n.code,{children:"1.x.x"})," branch remains unchanged."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"service-release-flow",children:"Service Release Flow"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Releasing Flow",src:t(2688).A+"",width:"792",height:"207"})}),"\n",(0,r.jsx)(n.p,{children:"Explanation:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The developer creates a PR"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["On merging to master ",(0,r.jsx)(n.code,{children:"release-please"})," takes action and opens a release PR with these changes:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Updating all relevant files with the new release version"}),"\n",(0,r.jsx)(n.li,{children:"Updating Changelog with the new version details"}),"\n",(0,r.jsx)(n.li,{children:"Updating helm (chart version)"}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["The release version will be based on ",(0,r.jsx)(n.a,{href:"https://semver.org/",children:"SemVer"})," (according to the PR title that will abide\n",(0,r.jsx)(n.a,{href:"https://github.com/conventional-changelog/commitlint",children:"commitlint"}),")"]})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["On merging the release PR to master, ",(0,r.jsx)(n.code,{children:"release-please"})," will create a new release"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"On new release, some automate workflows will be triggered (concurrently):"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Push to ",(0,r.jsx)(n.code,{children:"NPM"})," (for libraries)"]}),"\n",(0,r.jsxs)(n.li,{children:["Build a docker image and push to registry (if a ",(0,r.jsx)(n.code,{children:"Dockerfile"})," exists)"]}),"\n",(0,r.jsxs)(n.li,{children:["Pack the helm chart and push to registry (if a ",(0,r.jsx)(n.code,{children:"helm"})," chart exists)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"End State:"})," - New release version based on ",(0,r.jsx)(n.code,{children:"SemVer"})," - new release points to ",(0,r.jsx)(n.code,{children:"master"})," - New release is pushed to ",(0,r.jsx)(n.code,{children:"npm"}),", ",(0,r.jsx)(n.code,{children:"docker"})," and ",(0,r.jsx)(n.code,{children:"helm"})," registries"]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"The deployment flow is described in the next section"})}),"\n",(0,r.jsx)(n.h2,{id:"helming-strategy",children:"Helming Strategy"}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsx)(n.p,{children:"This strategy does not include the checks you should make during the development process such as running tests which should occur before the release.\nWe assume that the new released service is properly checked and its updated chart is properly constructed."})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Helming Strategy",src:t(4666).A+"",width:"675",height:"279"})}),"\n",(0,r.jsx)(n.p,{children:"The project includes two different repositories that represent two different flows:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:'Chart Flow using "Helm-Charts" repo'})," - Handling the structure of the libot charts. The structure will be similar to ",(0,r.jsx)(n.a,{href:"https://github.com/bitnami/charts/tree/main/bitnami",children:"bitnami"}),", like this:"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Helm Chart Structure",src:t(9158).A+"",width:"313",height:"581"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Every chart is a standalone chart."}),(0,r.jsx)(n.br,{}),"\n",'In this example, you can see every chart of raster, like: "raster-core" and "raster-ingestion" and a chart of whole raster\nthat should deploy the entire domain (this chart can contain the other charts of raster as sub-dependencies).']}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:'Values Flow using "Helm-Values" repo'})," - Handling the deployment in openshift based on the new charts that was created in ",(0,r.jsx)(n.code,{children:"helm-charts"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Helm Values Structure",src:t(4863).A+"",width:"495",height:"685"})}),"\n",(0,r.jsx)(n.h3,{id:"explanation",children:"Explanation"}),"\n",(0,r.jsxs)(n.p,{children:["The main goal is to separate the development part in ",(0,r.jsx)(n.code,{children:"helm-charts"})," (the structure) from the deployment part in ",(0,r.jsx)(n.code,{children:"helm-values"})," (the values)."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"helm-charts"})," repo will contain only the charts, which is the deployment structure, and a default ",(0,r.jsx)(n.code,{children:"values"})," file.\nThe structure shouldn't change much from now on (for the current set of features).",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.code,{children:"helm-values"})," repo will contain ",(0,r.jsx)(n.strong,{children:"only the values based on the relevant chart"}),"\nand the ",(0,r.jsx)(n.code,{children:"helm-chart"}),' version it\'s based on (a file named "charts-version.txt" in the repo).\nThe value files that represent openshift namespaces should not be part of the structure\n(as they are only config files), they should be in a different repo.']}),"\n",(0,r.jsx)(n.p,{children:"This gives us the following benefits:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:'Avoiding "irrelevant" commits'}),(0,r.jsx)(n.br,{}),"\n","Imagine if we keep the values with the chart. If we want to change the log level, for example, from ",(0,r.jsx)(n.code,{children:"info"})," to ",(0,r.jsx)(n.code,{children:"debug"}),",\nwe will have to commit the change as part of the chart. This is true for all changes made to any value.\nThis means we will clutter the repo with a lot of commits that don't have anything to do with the core of the chart itself."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Informative versions for helm-charts"}),(0,r.jsx)(n.br,{}),"\n","If we keep the chart and the values together, we will have a hard time properly handling the release of helm-chart due to\nthe many changes to the values (which aren't part of a release).\nOn the other hand, there are some value changes that are more meaningful that we want to document.\nFor example, you want to change the default port to be 80, This is a \"structure\" change because you want to set a new default value.\nIf you keep the values as part of the chart, you won't know what requires a new release and what doesn't.\nWhen they are separated, it is clearer what changes are a core part of your chart."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"One true structure"}),(0,r.jsx)(n.br,{}),"\n","Currently, the charts in the different networks are different from the charts in Azure because they can be modified.\nUsing the new strategy, we make sure that there will be one source of truth which is ",(0,r.jsx)(n.code,{children:"helm-charts"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simpler deployment"}),(0,r.jsx)(n.br,{}),"\n",'Keeping the values with the core structure forces us to manage every chart (along with the values) in different branches,\nwhich makes it harder to manage.\nWith the new strategy, we need to only "worry" about the values and the version of the chart before moving on to the deployment.\nWe can run this command template:',(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.code,{children:"helm install myrelease oci://HELM_REGISTRY/helm-charts/raster-ingestion --version VERSION"}),(0,r.jsx)(n.br,{}),"\n","And that's it! We don't need the chart in the repo anymore. We make the structure and the config independent of each other."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Let's walk through the flows!"}),"\n",(0,r.jsx)(n.h3,{id:"chart-flow",children:"Chart Flow"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Chart Flow",src:t(3399).A+"",width:"679",height:"113"})}),"\n",(0,r.jsxs)(n.p,{children:["This flow handles the update of ",(0,r.jsx)(n.code,{children:"helm-charts"})," and the creation of a new release version."]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["When a service has a new release and a helm folder exists, meaning that it's chart in helm-charts needs to be updated,\na PR will be automatically opened in ",(0,r.jsx)(n.code,{children:"helm-charts"})," with these changes:"]}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"update of the specific chart version"}),"\n",(0,r.jsxs)(n.li,{children:["update artifacts.json","\n",(0,r.jsxs)(n.admonition,{type:"info",children:[(0,r.jsx)(n.p,{children:"The developer should see the PR and make more changes if necessary"}),(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["The value of image tag won't be updated as we want to guide the teams to use ",(0,r.jsx)(n.code,{children:"appVersion"})," instead"]})})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"After the PR is ready, merge the PR."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["On push to ",(0,r.jsx)(n.code,{children:"master"}),", for every chart that uses the merged chart that was updated, there will be a PR similar to step 1."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["On push to ",(0,r.jsx)(n.code,{children:"master"}),", there will be a new PR using ",(0,r.jsx)(n.code,{children:"release-please"}),". The PR will be the updated chart version according to the commitlint"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Merging the PR of ",(0,r.jsx)(n.code,{children:"release-please"}),", will create a new release and attach to the release the artifacts.json"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"On new release, there will be a github workflow that will push the release to helm registry"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["After that, a new PR will be triggered to helm-values (starting the new section of ",(0,r.jsx)(n.a,{href:"#values-flow",children:"Values Flow"}),")"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"End State"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["New ",(0,r.jsx)(n.code,{children:"helm-charts"})," release version (of the specific chart)"]}),"\n",(0,r.jsx)(n.li,{children:"The release version exists also in the registry"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Now, we have an updated structure of the chart and we can move on to the values."}),"\n",(0,r.jsx)(n.h3,{id:"values-flow",children:"Values Flow"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Values Flow",src:t(7091).A+"",width:"644",height:"232"})}),"\n",(0,r.jsxs)(n.p,{children:["This flow handles the update of the namespace's values (",(0,r.jsx)(n.code,{children:"integration"})," and ",(0,r.jsx)(n.code,{children:"prod"}),") and the deployment in ",(0,r.jsx)(n.code,{children:"openshift"}),"."]}),"\n",(0,r.jsxs)(n.ol,{start:"0",children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["On new release of ",(0,r.jsx)(n.code,{children:"helm-charts"}),", there will be a PR on stage branch in ",(0,r.jsx)(n.code,{children:"helm-values"})," repo that updates the ",(0,r.jsx)(n.code,{children:"helm-charts"})," version in ",(0,r.jsx)(n.code,{children:"chart-version.txt"})," file"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"After running and testing the new chart (locally and remotely) and making sure the structure and values work as intended, you may merge the PR"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Once the stage branch is updated, it will be auto deployed to the ",(0,r.jsx)(n.code,{children:"integration"}),' namespace\nand a new PR will be automatically created in "prod" branch to update the ',(0,r.jsx)(n.code,{children:"helm-charts"})," version in the file"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"After the PR to the prod branch is created, it is the developer's responsibility to deploy and merge the PR."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"End State"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Updated values in all branches based on ",(0,r.jsx)(n.code,{children:"helm-charts"})," version"]}),"\n",(0,r.jsxs)(n.li,{children:["Updated ",(0,r.jsx)(n.code,{children:"chart-version.txt"})," file in every branch"]}),"\n",(0,r.jsx)(n.li,{children:"Updated deployments in all namespaces in openshift"}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["The values flow is the same flow in the network.\nThere will be helm-values repo based on branches (each branch will represent a namespace in openshift)\nand in every branch there will be a file named: ",(0,r.jsx)(n.code,{children:"chart-version.txt"})," that will represent the related chart version"]})}),"\n",(0,r.jsx)(n.h2,{id:"next-step---create-libot-version",children:'Next Step - Create "Libot Version"'}),"\n",(0,r.jsx)(n.h3,{id:"libot-version-strategy",children:"Libot Version Strategy"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Libot Version Strategy",src:t(5945).A+"",width:"701",height:"208"})}),"\n",(0,r.jsxs)(n.p,{children:['This flow handles the release of "',(0,r.jsx)(n.a,{href:"#libot-version-tag",children:"Libot Version"}),'".']}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Trigger through Jenkins the creation of new Libot Release Version.\nThe pipeline will allow you to choose from one of ",(0,r.jsx)(n.code,{children:"helm-charts"}),' releases the release you want to sign as new "Libot Version"']}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Jenkins will document in confluence the difference between the latest Libot Version and the new one that was just created.\nThe document should include also the changelog of the actual services rather than just the versions diff."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"At the end, the pipeline will trigger the bundler pipeline"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"bundle-strategy",children:"Bundle Strategy"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Bundling Strategy",src:t(6102).A+"",width:"572",height:"225"})}),"\n",(0,r.jsxs)(n.p,{children:["You can see more about bundler and unbundler ",(0,r.jsx)(n.a,{href:"/infra-portal/pr-preview/pr-26/docs/knowledge-base/DevOps/pipelines/bundler-unbundler",children:"here"}),".",(0,r.jsx)(n.br,{}),"\n","The only change is that the bundler pipeline will be able to create a bundle based on either ",(0,r.jsx)(n.code,{children:"helm-charts"}),' version or "Libot Version".']})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},9365:(e,n,t)=>{t.d(n,{A:()=>i});t(6540);var s=t(4164);const r={tabItem:"tabItem_Ymn6"};var a=t(4848);function i(e){let{children:n,hidden:t,className:i}=e;return(0,a.jsx)("div",{role:"tabpanel",className:(0,s.A)(r.tabItem,i),hidden:t,children:n})}},1470:(e,n,t)=>{t.d(n,{A:()=>y});var s=t(6540),r=t(4164),a=t(3104),i=t(6347),l=t(205),o=t(7485),h=t(1682),c=t(679);function d(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:n,children:t}=e;return(0,s.useMemo)((()=>{const e=n??function(e){return d(e).map((e=>{let{props:{value:n,label:t,attributes:s,default:r}}=e;return{value:n,label:t,attributes:s,default:r}}))}(t);return function(e){const n=(0,h.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function p(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:t}=e;const r=(0,i.W6)(),a=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,o.aZ)(a),(0,s.useCallback)((e=>{if(!a)return;const n=new URLSearchParams(r.location.search);n.set(a,e),r.replace({...r.location,search:n.toString()})}),[a,r])]}function x(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,a=u(e),[i,o]=(0,s.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const s=t.find((e=>e.default))??t[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:n,tabValues:a}))),[h,d]=m({queryString:t,groupId:r}),[x,g]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[r,a]=(0,c.Dv)(t);return[r,(0,s.useCallback)((e=>{t&&a.set(e)}),[t,a])]}({groupId:r}),f=(()=>{const e=h??x;return p({value:e,tabValues:a})?e:null})();(0,l.A)((()=>{f&&o(f)}),[f]);return{selectedValue:i,selectValue:(0,s.useCallback)((e=>{if(!p({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);o(e),d(e),g(e)}),[d,g,a]),tabValues:a}}var g=t(2303);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var j=t(4848);function b(e){let{className:n,block:t,selectedValue:s,selectValue:i,tabValues:l}=e;const o=[],{blockElementScrollPositionUntilNextRender:h}=(0,a.a_)(),c=e=>{const n=e.currentTarget,t=o.indexOf(n),r=l[t].value;r!==s&&(h(n),i(r))},d=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=o.indexOf(e.currentTarget)+1;n=o[t]??o[0];break}case"ArrowLeft":{const t=o.indexOf(e.currentTarget)-1;n=o[t]??o[o.length-1];break}}n?.focus()};return(0,j.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":t},n),children:l.map((e=>{let{value:n,label:t,attributes:a}=e;return(0,j.jsx)("li",{role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,ref:e=>o.push(e),onKeyDown:d,onClick:c,...a,className:(0,r.A)("tabs__item",f.tabItem,a?.className,{"tabs__item--active":s===n}),children:t??n},n)}))})}function w(e){let{lazy:n,children:t,selectedValue:a}=e;const i=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===a));return e?(0,s.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,j.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==a})))})}function v(e){const n=x(e);return(0,j.jsxs)("div",{className:(0,r.A)("tabs-container",f.tabList),children:[(0,j.jsx)(b,{...n,...e}),(0,j.jsx)(w,{...n,...e})]})}function y(e){const n=(0,g.A)();return(0,j.jsx)(v,{...e,children:d(e.children)},String(n))}},6102:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/bundler-strategy-9d9a9576be6f7d4a51cfe25e28288ea9.png"},3399:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/chart-flow-de2c6d9eed16f6b28d18df837c400fa8.png"},9158:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/helm-charts-structure-207ffe650df365df2533d2ee9ad19abe.png"},4666:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/helm-strategy-b7075e0cca52f150733a5a3bb74c9171.png"},4863:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/helm-values-structure-914fe8aa59a2eaa7a0dd905383762547.png"},5945:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/libot-version-strategy-25dadfb3d4ce09b6fbc8cfa3f3db9b44.png"},2688:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/release-on-repo-85c09b71b450cb7a6754bf597310c814.png"},7091:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/values-flow-af45b365062ec6daf63d42a5a3638dfa.png"},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var s=t(6540);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);