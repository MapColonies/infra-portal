"use strict";(self.webpackChunk_map_colonies_openapi_helpers=self.webpackChunk_map_colonies_openapi_helpers||[]).push([[9890],{7988:(e,r,i)=>{i.r(r),i.d(r,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"knowledge-base/ts-server-boilerplate/code","title":"Code","description":"The boilerplate code is written in TypeScript and uses the Express.js framework. Some of the source code goal is to provide a basic structure for the code, with packages that provide features that gives a good starting point for a new project. The business logic itself resides in the in resource directories under the src/ directory. In the boilerplate, the resources are resourceName and anotherResource, but you can rename them to match your project.","source":"@site/docs/knowledge-base/ts-server-boilerplate/code.md","sourceDirName":"knowledge-base/ts-server-boilerplate","slug":"/knowledge-base/ts-server-boilerplate/code","permalink":"/infra-portal/pr-preview/pr-34/docs/knowledge-base/ts-server-boilerplate/code","draft":false,"unlisted":false,"editUrl":"https://github.com/MapColonies/infra-portal/tree/master/docs/knowledge-base/ts-server-boilerplate/code.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"code","title":"Code","sidebar_position":1},"sidebar":"knowledgeBaseSidebar","previous":{"title":"TypeScript Server Boilerplate","permalink":"/infra-portal/pr-preview/pr-34/docs/knowledge-base/ts-server-boilerplate/"},"next":{"title":"Tests","permalink":"/infra-portal/pr-preview/pr-34/docs/knowledge-base/ts-server-boilerplate/tests"}}');var n=i(7773),s=i(6636);const o={id:"code",title:"Code",sidebar_position:1},a=void 0,c={},d=[{value:"index",id:"index",level:2},{value:"Healthcheck",id:"healthcheck",level:3},{value:"Server Builder",id:"server-builder",level:2},{value:"Openapi viewer",id:"openapi-viewer",level:3},{value:"Routers",id:"routers",level:3},{value:"Metrics middleware",id:"metrics-middleware",level:3},{value:"http logger",id:"http-logger",level:3},{value:"openapi validator",id:"openapi-validator",level:3},{value:"error handler",id:"error-handler",level:3},{value:"Container Config",id:"container-config",level:2},{value:"Config",id:"config",level:2},{value:"Telemetry",id:"telemetry",level:2},{value:"Logger",id:"logger",level:3},{value:"Metrics",id:"metrics",level:3},{value:"Tracing",id:"tracing",level:3},{value:"openapi",id:"openapi",level:2},{value:"TypeScript paths",id:"typescript-paths",level:2},{value:"Common Folder",id:"common-folder",level:2},{value:"Resource Structure",id:"resource-structure",level:2}];function l(e){const r={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.p,{children:["The boilerplate code is written in ",(0,n.jsx)(r.a,{href:"https://www.typescriptlang.org/",children:"TypeScript"})," and uses the ",(0,n.jsx)(r.a,{href:"https://expressjs.com/",children:"Express.js"})," framework. Some of the source code goal is to provide a basic structure for the code, with packages that provide features that gives a good starting point for a new project. The business logic itself resides in the in resource directories under the ",(0,n.jsx)(r.code,{children:"src/"})," directory. In the boilerplate, the resources are ",(0,n.jsx)(r.code,{children:"resourceName"})," and ",(0,n.jsx)(r.code,{children:"anotherResource"}),", but you can rename them to match your project."]}),"\n",(0,n.jsx)(r.h2,{id:"index",children:"index"}),"\n",(0,n.jsxs)(r.p,{children:["The entry point of the application is the ",(0,n.jsx)(r.code,{children:"src/index.ts"})," file. This file is responsible for starting the server and initializing the application. It imports the necessary modules and starts the server on the specified port."]}),"\n",(0,n.jsx)(r.p,{children:"The file also handles the error handling of critical errors (e.g. not errors that are part of a request)."}),"\n",(0,n.jsx)(r.h3,{id:"healthcheck",children:"Healthcheck"}),"\n",(0,n.jsxs)(r.p,{children:["The application healthcheck are configured in the ",(0,n.jsx)(r.code,{children:"src/healthcheck.ts"})," file. This file is responsible for checking the health of the application and returning a response to the client. The healthcheck is configured to return a 200 OK response if the application is healthy, otherwise the application is unhealthy."]}),"\n",(0,n.jsx)(r.p,{children:"You should customize the healthcheck to match your application needs. The default implementation is just a stub."}),"\n",(0,n.jsxs)(r.p,{children:["The healthchecks are implemented using the ",(0,n.jsx)(r.a,{href:"https://github.com/godaddy/terminus",children:(0,n.jsx)(r.code,{children:"@godaddy/terminus"})})," package."]}),"\n",(0,n.jsx)(r.h2,{id:"server-builder",children:"Server Builder"}),"\n",(0,n.jsxs)(r.p,{children:["The ",(0,n.jsx)(r.code,{children:"src/serverBuilder.ts"})," file is responsible for creating the Express.js server and configuring it with the necessary middleware and routes."]}),"\n",(0,n.jsx)(r.h3,{id:"openapi-viewer",children:"Openapi viewer"}),"\n",(0,n.jsxs)(r.p,{children:["The OpenAPI viewer is configured and enables to view the OpenAPI documentation in the browser. By default, the OpenAPI viewer is configured to serve the OpenAPI documentation at the ",(0,n.jsx)(r.code,{children:"/docs/api"})," endpoint. You can customize the endpoint by changing the configuration."]}),"\n",(0,n.jsxs)(r.p,{children:["For more information on how to use the OpenAPI viewer, check the ",(0,n.jsx)(r.a,{href:"/infra-portal/pr-preview/pr-34/docs/knowledge-base/packages/openapi-express-viewer/",children:"openapi-express-viewer documentation"}),"."]}),"\n",(0,n.jsx)(r.h3,{id:"routers",children:"Routers"}),"\n",(0,n.jsxs)(r.p,{children:["The routers are configured in the ",(0,n.jsx)(r.code,{children:"src/serverBuilder.ts"})," file. The routers are responsible for handling the requests and returning the responses. The routers are organized by resource, with each resource having its own router."]}),"\n",(0,n.jsxs)(r.p,{children:["When adding a new resource, you should create a new router and add it to the ",(0,n.jsx)(r.code,{children:"src/serverBuilder.ts"})," file. The router should be imported from the resource directory."]}),"\n",(0,n.jsx)(r.h3,{id:"metrics-middleware",children:"Metrics middleware"}),"\n",(0,n.jsxs)(r.p,{children:["The metrics middleware exposes NodeJS, express and custom metrics to ",(0,n.jsx)(r.a,{href:"https://prometheus.io/",children:"Prometheus"}),". The metrics are exposed at the ",(0,n.jsx)(r.code,{children:"/metrics"})," endpoint."]}),"\n",(0,n.jsxs)(r.p,{children:["For more information check the ",(0,n.jsx)(r.a,{href:"/infra-portal/pr-preview/pr-34/docs/knowledge-base/packages/telemetry/",children:"MapColonies Telemetry package"}),"."]}),"\n",(0,n.jsx)(r.h3,{id:"http-logger",children:"http logger"}),"\n",(0,n.jsx)(r.p,{children:"The HTTP logger middleware is responsible for logging the requests and responses. The logger is configured to use the application logger to log those requests."}),"\n",(0,n.jsxs)(r.p,{children:["For more information check the ",(0,n.jsx)(r.a,{href:"/infra-portal/pr-preview/pr-34/docs/knowledge-base/packages/express-access-log-middleware/",children:"express-access-log-middleware package"}),"."]}),"\n",(0,n.jsx)(r.h3,{id:"openapi-validator",children:"openapi validator"}),"\n",(0,n.jsxs)(r.p,{children:["The boilerplate validates all the requests using the ",(0,n.jsx)(r.a,{href:"https://cdimascio.github.io/express-openapi-validator-documentation/",children:"express-openapi-validator package"}),". The package uses the OpenAPI schema to validate the requests."]}),"\n",(0,n.jsx)(r.h3,{id:"error-handler",children:"error handler"}),"\n",(0,n.jsx)(r.p,{children:"The error handler is responsible for handling the errors that occur in the application. The error handler is configured to return a JSON response with the error message and the status code."}),"\n",(0,n.jsxs)(r.p,{children:["For more information check the ",(0,n.jsx)(r.a,{href:"/infra-portal/pr-preview/pr-34/docs/knowledge-base/packages/error-express-handler/",children:"error-express-handler package"}),"."]}),"\n",(0,n.jsx)(r.h2,{id:"container-config",children:"Container Config"}),"\n",(0,n.jsxs)(r.p,{children:["The container config file is responsible for configuring the dependency injection container. The container is used to manage the dependencies of the application and to inject them into the classes that need them.\nThe container is configured using the ",(0,n.jsx)(r.code,{children:"tsyringe"})," package. The package is used to create the container and to register the dependencies."]}),"\n",(0,n.jsxs)(r.p,{children:["The boilerplate comes with a few default dependencies that are registered in the container. If the registered object is not a class, you can use the interface ",(0,n.jsx)(r.code,{children:"SERVICES"})," under ",(0,n.jsx)(r.code,{children:"src/common/constants.ts"})," to make it easier to find and share the registered object."]}),"\n",(0,n.jsxs)(r.p,{children:["For more information check the ",(0,n.jsxs)(r.a,{href:"https://github.com/microsoft/tsyringe",children:[(0,n.jsx)(r.code,{children:"tsyringe"})," package documentation"]}),"."]}),"\n",(0,n.jsx)(r.h2,{id:"config",children:"Config"}),"\n",(0,n.jsx)(r.p,{children:"The boilerplate is configured with the MapColonies configuration package. The package is used to manage the configuration of the application and to load the configuration from a central server or environment variables."}),"\n",(0,n.jsxs)(r.p,{children:["The config is defined under ",(0,n.jsx)(r.code,{children:"src/common/config.ts"})," file and uses the schema defined for the boilerplate. As you implement your own service, you should create a new schema that matches your service configuration and extends the boilerplate's one."]}),"\n",(0,n.jsx)(r.p,{children:"Check the following resources for more information:"}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/infra-portal/pr-preview/pr-34/docs/knowledge-base/config-management/",children:"Config management docs"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/infra-portal/pr-preview/pr-34/docs/guides/config-management/zero-to-hero",children:"Config getting started guide"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/infra-portal/pr-preview/pr-34/docs/knowledge-base/packages/config/",children:"MapColonies config package"})}),"\n"]}),"\n",(0,n.jsx)(r.h2,{id:"telemetry",children:"Telemetry"}),"\n",(0,n.jsx)(r.p,{children:"The boilerplate comes with multiple options to monitor and observe your application. For best results, you should use all of them and tailor them to your needs."}),"\n",(0,n.jsx)(r.h3,{id:"logger",children:"Logger"}),"\n",(0,n.jsxs)(r.p,{children:["The logger used by the boiler plate is MapColonies ",(0,n.jsx)(r.a,{href:"/infra-portal/pr-preview/pr-34/docs/knowledge-base/packages/js-logger/",children:(0,n.jsx)(r.code,{children:"js-logger"})}),". The logger is available for usage by injecting it into your class using the ",(0,n.jsx)(r.code,{children:"@inject"})," decorator."]}),"\n",(0,n.jsxs)(r.p,{children:["The logger is also configured to log the requests and responses using the ",(0,n.jsx)(r.code,{children:"express-access-log-middleware"})," package as explained ",(0,n.jsx)(r.a,{href:"#http-logger",children:"here"}),"."]}),"\n",(0,n.jsx)(r.h3,{id:"metrics",children:"Metrics"}),"\n",(0,n.jsxs)(r.p,{children:["Metrics are handled by the ",(0,n.jsx)(r.a,{href:"https://github.com/siimon/prom-client",children:(0,n.jsx)(r.code,{children:"prom-client"})})," package. The metrics are exposed at the ",(0,n.jsx)(r.code,{children:"/metrics"})," endpoint and are collected by Prometheus. The metrics are configured to collect NodeJS, express and custom metrics."]}),"\n",(0,n.jsxs)(r.p,{children:["Information about the metrics middleware is also available ",(0,n.jsx)(r.a,{href:"#metrics-middleware",children:"here"}),"."]}),"\n",(0,n.jsx)(r.h3,{id:"tracing",children:"Tracing"}),"\n",(0,n.jsxs)(r.p,{children:["The boilerplate is instrumented using ",(0,n.jsx)(r.a,{href:"https://opentelemetry.io/",children:"OpenTelemetry"}),". To ease with the implementation of tracing, the package uses the ",(0,n.jsx)(r.a,{href:"/infra-portal/pr-preview/pr-34/docs/knowledge-base/packages/telemetry/",children:"Telemetry package"})," that handles the initialization and configuration of the OpenTelemetry SDK. In addition the package also exposes helpers which you can use to instrument your code."]}),"\n",(0,n.jsxs)(r.p,{children:["The tracing is defined in the ",(0,n.jsx)(r.code,{children:"src/common/tracing.ts"})," file and loaded in the ",(0,n.jsx)(r.code,{children:"src/instrumentation.mts"})," file."]}),"\n",(0,n.jsx)(r.admonition,{type:"warning",children:(0,n.jsxs)(r.p,{children:["The ",(0,n.jsx)(r.code,{children:"instrumentation.mts"})," file must be loaded before the application loads. This can be done by using NodeJS ",(0,n.jsx)(r.code,{children:"--import"})," flag. The NPM scripts and dockerfile are already configured to do so. If you are using a different way to load the application, make sure to load the ",(0,n.jsx)(r.code,{children:"instrumentation.mts"})," file before the application loads."]})}),"\n",(0,n.jsx)(r.h2,{id:"openapi",children:"openapi"}),"\n",(0,n.jsxs)(r.p,{children:["The boilerplate is a design first project. You should first design your API using the OpenAPI schema and then implement the code. The OpenAPI schema is located in the ",(0,n.jsx)(r.code,{children:"openapi"})," directory. The OpenAPI schema is used to generate the types for the project."]}),"\n",(0,n.jsxs)(r.p,{children:["For your convenience you can use the ",(0,n.jsx)(r.code,{children:"openapi-helpers"})," package to type the request handlers in your controllers. For more information check the ",(0,n.jsx)(r.a,{href:"/infra-portal/pr-preview/pr-34/docs/knowledge-base/packages/openapi-helpers/",children:(0,n.jsx)(r.code,{children:"openapi-helpers"})})," package."]}),"\n",(0,n.jsx)(r.h2,{id:"typescript-paths",children:"TypeScript paths"}),"\n",(0,n.jsxs)(r.p,{children:["The boilerplate supports the use of TypeScript ",(0,n.jsx)(r.a,{href:"https://www.typescriptlang.org/tsconfig/#paths",children:(0,n.jsx)(r.code,{children:"paths feature"})}),". You can add your own paths by adding a new one to the ",(0,n.jsx)(r.code,{children:"tsconfig.json"})," file. The paths are defined under the ",(0,n.jsx)(r.code,{children:"compilerOptions.paths"})," property."]}),"\n",(0,n.jsxs)(r.p,{children:["The aliases are resolved to relative path after compilation using the ",(0,n.jsx)(r.a,{href:"https://github.com/justkey007/tsc-alias",children:(0,n.jsx)(r.code,{children:"tsc-alias"})})," package. For the tests, the aliases are resolved by mapping the paths using jest."]}),"\n",(0,n.jsx)(r.h2,{id:"common-folder",children:"Common Folder"}),"\n",(0,n.jsxs)(r.p,{children:["The ",(0,n.jsx)(r.code,{children:"src/common"})," directory contains common code that is used by the application. It contains constants, interfaces, and types that are used by the application. You can extends the common code to add your own custom code."]}),"\n",(0,n.jsx)(r.h2,{id:"resource-structure",children:"Resource Structure"}),"\n",(0,n.jsxs)(r.p,{children:["Each resource in the project is a directory under the ",(0,n.jsx)(r.code,{children:"src/"})," directory. The resource directory is separated into the following directories:"]}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:["\n",(0,n.jsx)(r.p,{children:"Model - Contains your model, types and business logic."}),"\n"]}),"\n",(0,n.jsxs)(r.li,{children:["\n",(0,n.jsx)(r.p,{children:"Controller - Contains the request handlers for the resource. Anything HTTP related should be in this directory."}),"\n"]}),"\n",(0,n.jsxs)(r.li,{children:["\n",(0,n.jsxs)(r.p,{children:["Routes - Contains the routes that map the request handlers to the endpoints. The routes are defined using the OpenAPI schema. The routes should be added to the router in the ",(0,n.jsx)(r.code,{children:"src/serverBuilder.ts"})," file."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},6636:(e,r,i)=>{i.d(r,{R:()=>o,x:()=>a});var t=i(8441);const n={},s=t.createContext(n);function o(e){const r=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),t.createElement(s.Provider,{value:r},e.children)}}}]);